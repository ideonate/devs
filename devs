#!/usr/bin/env zsh

# devs - DevContainer Management Script
# Manages multiple named devcontainers for the current project

set -euo pipefail

# Configuration
SCRIPT_NAME="devs"
PROJECT_PREFIX="dev"

# Get project info
get_project_info() {
    local project_dir=$(pwd)
    
    # Get project name from git repo (org-repo format)
    local project_name
    local git_remote_url=""
    if git remote get-url origin >/dev/null 2>&1; then
        git_remote_url=$(git remote get-url origin)
        project_name=$(echo "$git_remote_url" | sed 's/.*github\.com[/:]//' | sed 's/\.git$//' | tr '[:upper:]' '[:lower:]' | tr '/' '-')
    else
        project_name=$(basename "$project_dir" | tr '[:upper:]' '[:lower:]')
        echo "‚ö†Ô∏è  Not a git repo, using directory name: $project_name" >&2
    fi
    
    local project_hex=$(printf "$project_dir" | xxd -p | tr -d '\n')
    
    echo "$project_dir|$project_name|$project_hex|$git_remote_url"
}

# Check if devcontainer.json exists
check_devcontainer() {
    if [[ ! -f ".devcontainer/devcontainer.json" ]]; then
        echo "‚ùå Error: No .devcontainer/devcontainer.json found in current directory"
        echo "   Make sure you're in a project with devcontainer configuration"
        exit 1
    fi
}

# Check if devcontainer image should be rebuilt
should_rebuild_image() {
    local project_dir="$1"
    local dev_name="$2"
    local project_name="$3"
    
    # Try to find existing image for this devcontainer configuration
    # The devcontainer CLI creates images with predictable naming patterns
    local image_pattern="vsc-$(basename "$project_dir")"
    local existing_images=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "^${image_pattern}" || true)
    
    if [[ -z "$existing_images" ]]; then
        return 1  # No existing image, don't need --rebuild for new builds
    fi
    
    # Get the most recent image creation time
    local newest_image_epoch=0
    while IFS= read -r image_name; do
        if [[ -n "$image_name" ]]; then
            local image_created=$(docker inspect --format='{{.Created}}' "$image_name" 2>/dev/null || echo "")
            if [[ -n "$image_created" ]]; then
                local image_epoch
                if command -v gdate >/dev/null 2>&1; then
                    image_epoch=$(gdate -d "$image_created" +%s 2>/dev/null || echo "0")
                else
                    # Remove microseconds and timezone for BSD date parsing
                    local clean_date=$(echo "$image_created" | sed 's/\.[0-9]*Z$//' | sed 's/Z$//')
                    image_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%S" "$clean_date" +%s 2>/dev/null || echo "0")
                fi
                
                if [[ "$image_epoch" -gt "$newest_image_epoch" ]]; then
                    newest_image_epoch="$image_epoch"
                fi
            fi
        fi
    done <<< "$existing_images"
    
    if [[ "$newest_image_epoch" -eq 0 ]]; then
        return 1  # Could not determine image age, don't rebuild
    fi
    
    # Check if any devcontainer-related files are newer than the newest image
    local devcontainer_files=(".devcontainer" "Dockerfile" "docker-compose.yml" "docker-compose.yaml")
    
    for file_pattern in "${devcontainer_files[@]}"; do
        if [[ -e "$project_dir/$file_pattern" ]]; then
            local file_epoch
            if [[ -d "$project_dir/$file_pattern" ]]; then
                # For directories, check the newest file inside
                file_epoch=$(find "$project_dir/$file_pattern" -type f -exec stat -f "%m" {} \; 2>/dev/null | sort -n | tail -1 || echo "0")
            else
                # For files, get modification time
                file_epoch=$(stat -f "%m" "$project_dir/$file_pattern" 2>/dev/null || echo "0")
            fi
            
            if [[ "$file_epoch" -gt "$newest_image_epoch" ]]; then
                return 0  # Need rebuild - files newer than image
            fi
        fi
    done
    
    return 1  # No rebuild needed
}

# Generate container name with consistent prefix
get_container_name() {
    local dev_name="$1"
    local project_name="$2"
    echo "${PROJECT_PREFIX}-${project_name}-${dev_name}"
}

# Start a single devcontainer if not already running
ensure_container_running() {
    local dev_name="$1"
    local project_name="$2"
    local project_dir="$3"
    local git_remote_url="$4"
    local container_name=$(get_container_name "$dev_name" "$project_name")
    
    # Check if we need to rebuild the image
    local rebuild_flag=""
    if should_rebuild_image "$project_dir" "$dev_name" "$project_name"; then
        echo "   üîÑ Devcontainer configuration changed, will rebuild image..."
        rebuild_flag="--build-no-cache"
    fi
    
    # Check if container is already running using labels
    local existing_container=$(docker ps --filter "label=devs.project=$project_name" --filter "label=devs.dev=$dev_name" --format "{{.Names}}" | head -1)
    if [[ -n "$existing_container" ]]; then
        if [[ -n "$rebuild_flag" ]]; then
            echo "   üîÑ Container running but needs rebuild, stopping first..."
            docker stop "$existing_container" >/dev/null 2>&1 || true
            docker rm "$existing_container" >/dev/null 2>&1 || true
        else
            return 0  # Already running and up to date
        fi
    fi
    
    echo "   üöÄ Container not running, starting $dev_name first..."
    
    # Create a unique workspace folder path for each dev
    local unique_workspace_dir="${project_dir}-${dev_name}"
    
    # Create a real copy if it doesn't exist
    if [[ ! -e "$unique_workspace_dir" ]]; then
        echo "   üìÇ Creating isolated workspace copy for $dev_name..."
        # Copy all files tracked by git or unignored, including untracked but not gitignored
        git -C "$project_dir" ls-files -z --cached --others --exclude-standard | \
          rsync -a --files-from=- --from0 "$project_dir"/ "$unique_workspace_dir"/

        # Copy the .git and .claude directories
        rsync -a "$project_dir/.git/" "$unique_workspace_dir/.git/"
        echo "Copy .claude"
        rsync -a "$project_dir/.claude/" "$unique_workspace_dir/.claude/"

        # Explicitly copy .devcontainer/.env if it exists
        if [[ -f "$project_dir/.devcontainer/.env" ]]; then
          mkdir -p "$unique_workspace_dir/.devcontainer"
          rsync -a "$project_dir/.devcontainer/.env" "$unique_workspace_dir/.devcontainer/.env"
        fi

        echo "   ‚úÖ Directory copied to $unique_workspace_dir (excluding build directories)"
    else
        echo "   üìÅ Using existing workspace at $unique_workspace_dir"
    fi
    
    # Start devcontainer with unique workspace folder
    local workspace_name=$(basename "$project_dir")
    DEVCONTAINER_NAME="$dev_name" \
    GIT_REMOTE_URL="$git_remote_url" \
    WORKSPACE_FOLDER_NAME="${workspace_name}-${dev_name}" \
    devcontainer up \
        --workspace-folder "$unique_workspace_dir" \
        --id-label "devs.project=$project_name" \
        --id-label "devs.dev=$dev_name" \
        --remove-existing-container \
        $rebuild_flag || {
        # Clean up any failed containers using labels
        echo "   ‚ùå Devcontainer up failed, cleaning up..."
        local failed_container=$(docker ps -a --filter "label=devs.project=$project_name" --filter "label=devs.dev=$dev_name" --format "{{.Names}}" | head -1)
        if [[ -n "$failed_container" ]]; then
            docker stop "$failed_container" >/dev/null 2>&1 || true
            docker rm "$failed_container" >/dev/null 2>&1 || true
            echo "   üóëÔ∏è  Removed failed container: $failed_container"
        fi
        return 1  # Failed to start
    }
    
    # Get the container that was created using labels
    local created_container=$(docker ps --filter "label=devs.project=$project_name" --filter "label=devs.dev=$dev_name" --format "{{.Names}}" | head -1)
    
    # Verify container is actually healthy/ready
    if [[ -n "$created_container" ]]; then
        echo "   üîç Checking container health..."
        
        # Test if we can execute a simple command in the container
        if ! docker exec "$created_container" /bin/sh -c "echo 'Container ready'" >/dev/null 2>&1; then
            echo "   ‚ùå Container started but is not responding, cleaning up..."
            docker stop "$created_container" >/dev/null 2>&1 || true
            docker rm "$created_container" >/dev/null 2>&1 || true
            return 1  # Failed - container not healthy
        fi
        
        # Rename container to our custom name if needed
        if [[ "$created_container" != "$container_name" ]]; then
            docker rename "$created_container" "$container_name" 2>/dev/null || {
                echo "   ‚ö†Ô∏è  Could not rename container to $container_name"
            }
        fi
    else
        echo "   ‚ùå No container found after devcontainer up"
        return 1  # Failed - no container created
    fi
    
    echo "   ‚úÖ Started: $dev_name"
    return 0  # Success
}

# Start devcontainers
cmd_start() {
    local dev_names=("$@")
    
    if [[ ${#dev_names[@]} -eq 0 ]]; then
        echo "‚ùå Usage: $SCRIPT_NAME start <dev-name> [dev-name...]"
        echo "   Example: $SCRIPT_NAME start sally bob"
        exit 1
    fi
    
    check_devcontainer
    
    local info=$(get_project_info)
    local project_dir=$(echo "$info" | cut -d'|' -f1)
    local project_name=$(echo "$info" | cut -d'|' -f2)
    local git_remote_url=$(echo "$info" | cut -d'|' -f4)
    local workspace_name=$(basename "$project_dir")
    
    echo "üöÄ Starting devcontainers for project: $project_name"
    
    for dev_name in "${dev_names[@]}"; do
        local container_name=$(get_container_name "$dev_name" "$project_name")
        
        echo "   Starting: $dev_name (container: $container_name)"
        
        if ! ensure_container_running "$dev_name" "$project_name" "$project_dir" "$git_remote_url"; then
            echo "   ‚ö†Ô∏è  Failed to start $dev_name, continuing with others..."
            continue
        fi
    done
    
    echo ""
    echo "üí° To open containers in VS Code:"
    echo "   $SCRIPT_NAME open ${dev_names[*]}"
}

# Open devcontainers in VS Code
cmd_open() {
    local dev_names=("$@")
    
    if [[ ${#dev_names[@]} -eq 0 ]]; then
        echo "‚ùå Usage: $SCRIPT_NAME open <dev-name> [dev-name...]"
        echo "   Example: $SCRIPT_NAME open sally bob"
        exit 1
    fi
    
    check_devcontainer
    
    local info=$(get_project_info)
    local project_dir=$(echo "$info" | cut -d'|' -f1)
    local project_name=$(echo "$info" | cut -d'|' -f2)
    local project_hex=$(echo "$info" | cut -d'|' -f3)
    local git_remote_url=$(echo "$info" | cut -d'|' -f4)
    local workspace_name=$(basename "$project_dir")
    
    echo "üìÇ Opening devcontainers in VS Code for project: $project_name"
    
    for dev_name in "${dev_names[@]}"; do
        echo "   Opening: $dev_name"
        
        # Ensure container is running
        if ! ensure_container_running "$dev_name" "$project_name" "$project_dir" "$git_remote_url"; then
            echo "   ‚ùå Failed to start $dev_name, skipping..."
            continue
        fi
        
        # Use the unique workspace folder path for devcontainer connection
        local unique_workspace_dir="${project_dir}-${dev_name}"
        local unique_hex=$(printf "$unique_workspace_dir" | xxd -p | tr -d '\n')
        
        # Launch VS Code pointing to the cloned project directory inside container
        # This seems to also make a new container
        local unique_workspace_name="${workspace_name}-${dev_name}"
        local vscode_uri="vscode-remote://dev-container+${unique_hex}/workspaces/${unique_workspace_name}"


        ## Maybe this won't start a new container, but it doesn't work...
        # local container_name=$(get_container_name "$dev_name" "$project_name")
        # local unique_hex2=$(printf "$container_name" | xxd -p | tr -d '\n')
        # local vscode_uri="vscode-remote://attached-container+${unique_hex2}/workspaces/${unique_workspace_name}"
        
        echo "   üöÄ Opening VS Code for: $dev_name"
        echo "   Command: DEVCONTAINER_NAME=\"$dev_name\" code --folder-uri \"$vscode_uri\""
        
        DEVCONTAINER_NAME="$dev_name" code \
            --folder-uri "$vscode_uri" &
        
        echo "   ‚úÖ Launched VS Code for: $dev_name"
        sleep 2  # Longer delay to ensure windows open separately
    done
    
    echo ""
    echo "üí° VS Code windows should open shortly with titles: '<dev-name> - Claude Code Sandbox'"
}

# Stop and remove devcontainers
cmd_stop() {
    local dev_names=("$@")
    
    if [[ ${#dev_names[@]} -eq 0 ]]; then
        echo "‚ùå Usage: $SCRIPT_NAME stop <dev-name> [dev-name...]"
        echo "   Example: $SCRIPT_NAME stop sally"
        exit 1
    fi
    
    local info=$(get_project_info)
    local project_name=$(echo "$info" | cut -d'|' -f2)
    
    echo "üõë Stopping devcontainers for project: $project_name"
    
    for dev_name in "${dev_names[@]}"; do
        local container_name=$(get_container_name "$dev_name" "$project_name")
        
        echo "   Stopping: $dev_name (container: $container_name)"
        
        # Stop and remove container
        if docker ps -a --format "{{.Names}}" | grep -q "^${container_name}$"; then
            docker stop "$container_name" >/dev/null 2>&1 || true
            docker rm "$container_name" >/dev/null 2>&1 || true
            echo "   ‚úÖ Stopped and removed: $dev_name"
        else
            echo "   ‚ö†Ô∏è  Container not found: $dev_name"
        fi
        
    done
}

# List active devcontainers for current project
cmd_list() {
    local info=$(get_project_info)
    local project_name=$(echo "$info" | cut -d'|' -f2)
    
    echo "üìã Active devcontainers for project: $project_name"
    echo ""
    
    # Find containers with our project label
    local containers=$(docker ps -a --filter "label=devs.project=$project_name" --format "{{.Names}}\t{{.Status}}\t{{.Label \"devs.dev\"}}" 2>/dev/null || true)
    
    if [[ -z "$containers" ]]; then
        echo "   No active devcontainers found"
        echo ""
        echo "üí° Start some with: $SCRIPT_NAME start <dev-name>"
        return
    fi
    
    echo "   Name        Status           Container"
    echo "   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    while IFS=$'\t' read -r container_name container_status dev_name; do
        if [[ -n "$dev_name" ]]; then
            printf "   %-10s  %-15s  %s\n" "$dev_name" "$container_status" "$container_name"
        fi
    done <<< "$containers"
    
    echo ""
    echo "üí° Open with: $SCRIPT_NAME open <dev-name>"
    echo "üí° Stop with: $SCRIPT_NAME stop <dev-name>"
}

# Shell into a devcontainer
cmd_shell() {
    local dev_names=("$@")
    
    if [[ ${#dev_names[@]} -ne 1 ]]; then
        echo "‚ùå Usage: $SCRIPT_NAME shell <dev-name>"
        echo "   Example: $SCRIPT_NAME shell sally"
        exit 1
    fi
    
    local dev_name="$1"
    local info=$(get_project_info)
    local project_dir=$(echo "$info" | cut -d'|' -f1)
    local project_name=$(echo "$info" | cut -d'|' -f2)
    local git_remote_url=$(echo "$info" | cut -d'|' -f4)
    local container_name=$(get_container_name "$dev_name" "$project_name")
    local workspace_name=$(basename "$project_dir")
    
    # The workspace directory inside the container
    local container_workspace_dir="/workspaces/${workspace_name}-${dev_name}"
    
    echo "üêö Opening shell in: $dev_name (container: $container_name)"
    echo "   Workspace: $container_workspace_dir"
    
    # Ensure container is running
    if ! ensure_container_running "$dev_name" "$project_name" "$project_dir" "$git_remote_url"; then
        echo "‚ùå Failed to start $dev_name"
        exit 1
    fi
    
    # Execute shell in container, changing to the workspace directory
    docker exec -it -w "$container_workspace_dir" "$container_name" /bin/zsh
}

# Show help
cmd_help() {
    cat << EOF
$SCRIPT_NAME - DevContainer Management Script

USAGE:
    $SCRIPT_NAME <command> [arguments]

COMMANDS:
    start <name...>    Start named devcontainers
    open <name...>     Open devcontainers in VS Code  
    stop <name...>     Stop and remove devcontainers
    shell <name>       Open shell in devcontainer
    list               List active devcontainers for current project
    help               Show this help

EXAMPLES:
    $SCRIPT_NAME start sally bob      # Start two devcontainers
    $SCRIPT_NAME open sally           # Open sally's container in VS Code  
    $SCRIPT_NAME stop bob             # Stop and remove bob's container
    $SCRIPT_NAME list                 # Show all active containers

NOTES:
    - Run from project root directory with .devcontainer/devcontainer.json
    - Project name derived from git repo (org-repo format)
    - Container names: dev-<project>-<dev-name>
    - VS Code windows show custom titles based on dev names
    - Requires: devcontainer CLI, Docker, VS Code

CURRENT PROJECT: $(get_project_info | cut -d'|' -f2)

EOF
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        start)
            cmd_start "$@"
            ;;
        open)
            cmd_open "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        shell)
            cmd_shell "$@"
            ;;
        list|ls)
            cmd_list "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            echo "‚ùå Unknown command: $command"
            echo "   Run '$SCRIPT_NAME help' for usage information"
            exit 1
            ;;
    esac
}

# Check dependencies
check_deps() {
    local missing=()
    
    command -v devcontainer >/dev/null 2>&1 || missing+=("devcontainer CLI")
    command -v docker >/dev/null 2>&1 || missing+=("docker")
    command -v code >/dev/null 2>&1 || missing+=("VS Code 'code' command")
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo "‚ùå Missing dependencies:"
        printf "   - %s\n" "${missing[@]}"
        echo ""
        echo "Install missing tools and try again."
        exit 1
    fi
}

# Entry point
if [[ "${(%):-%N}" == "${0}" ]] || [[ "${BASH_SOURCE[0]:-}" == "${0}" ]]; then
    check_deps
    main "$@"
fi
